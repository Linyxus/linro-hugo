---
title: "「算法笔记」基础排序算法"
date: 2019-01-26T22:19:46+08:00
showDate: true
tags: ["algorithm", "note"]
---

这是这个冬天算法学习留下的第一篇笔记。

排序算法，是最基础的算法之一了吧。两年前或是三年前，我大概也是这样慢慢熟悉了他们。

算法是不会变的。

那么，就从这里开始吧。

## 插入排序

插入排序算不上高效的排序算法，从时间复杂度来说，和冒泡排序是相抵的。其实本质上，插入排序和冒泡排序相似甚至相同，只是“冒泡”的方向不同。

```c++
void insert_sort()
{
  for (int i = 1; i < n; i++) {
    for (int j = i; j > 0; j--) {
      if (arr[j] < arr[j-1]) {
        int temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
      }
    }
  }
  return;
}
```

在算法实现`insert_sort`执行的过程中，有这件事情得以保证：0..i-1这些元素已经排好序。

而关于变量`j`的那个循环，所做的事情就是“冒泡”，而这里的冒泡本质上也就是插入。

时间复杂度为$O(n^2)​$。

## 归并排序

归并排序是利用了分治思想的排序算法。

- 分解问题：将要排序的数组分成两部分，将两部分分别排序。
- 合并：将两部分合并。

```c++
void merge_sort(int *begin, int *end)
{
  int l = end - begin;
  if (l == 0 || l == 1) {
    return;
  }
  int m = l / 2;
  merge_sort(begin, begin+m);
  merge_sort(begin+m, end);
  int p = 0;
  int q = m;
  int cnt = 0;
  while (p < m || q < l) {
    if (q >= l || (p < m && *(begin+p) <= *(begin+q))) {
      tmp[cnt++] = *(begin+p);
      p++;
    } else {
      tmp[cnt++] = *(begin+q);
      q++;
    }
  }
  for (int i = 0; i < l; i++) {
    *(begin+i) = tmp[i];
  }
}
```

分解问题无甚好说，重要的在于合并。

合并的思想有个很棒的类比：你有两堆牌，它们都是排好序的，将它们合并成一堆排好序的牌的方法是比较它们最上面的那张牌，将更小的放入合并的牌堆。当某一堆牌放完，直接把另一堆牌全部放入合并的牌堆即可。

这里用到了临时的额外空间。

时间复杂度为$O(nlogn)$。

## 快速排序

快速排序也是利用了分治思想的排序算法。只是求解问题的方法与归并排序有所不同。

- 分解问题：将数组分成两个部分，满足：左半部分任意一个数都小于等于右半部分。再将这两个部分划分，直到不能再划分。
- 合并：不必合并，此时数组已有序。

```c++
void quick_sort(int *begin, int *end)
{
  if (begin == end) {
    return;
  }
  int *l = begin;
  int *r = end-1;
  int t = *l;
  while (l < r) {
    while (l < r && *r >= t) {
      r--;
    }
    *l = *r;
    while (l < r && *l <= t) {
      l++;
    }
    *r = *l;
  }
  *l = t;
  quick_sort(begin, l);
  quick_sort(l+1, end);
}
```

快速排序实现的关键在于划分的方法。上面这个方法算得上主流的一个，不必额外空间，可以理解成一次长长的交换。

在循环的过程中，这些事情得以保证：

1. 无论何时，都有一个空位可以放入数字。
2. 循环开始时，这个空位是`l`。
3. 空位在`l`和`r`之间轮换。
4. 递减`r`时，`l`总是空位，反之亦然。
5. 赋值操作事实上完成了空位的轮换。
6. begin…l之间的数都小于等于t
7. r…end-1之间的数都大于等于t

值得一提的是，如此实现的快速排序是不稳定的。

快速排序的时间复杂度在最好情况下是$O(nlogn)$，最坏情况下与插入排序及冒泡排序比肩，到达$O(n^2)$。

但大多数情况下，快速排序的效率远高于插入排序，也快于归并排序。

第一篇笔记，就写到这里。