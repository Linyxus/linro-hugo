#+hugo_base_dir: ../

#+seq_todo: TODO DRAFT DONE
#+seq_todo: TEST__TODO | TEST__DONE

#+property: header-args :eval never-export

#+startup: indent

#+macro: doc [[https://ox-hugo.scripter.co/doc/$1][$2]]
#+macro: oxhugoissue =ox-hugo= Issue #[[https://github.com/kaushalmodi/ox-hugo/issues/$1][$1]]
#+macro: hugoissue =hugo= Issue #[[https://github.com/gohugoio/hugo/issues/$1][$1]]
#+macro: hugopr =hugo= PR #[[https://github.com/gohugoio/hugo/pull/$1][$1]]
#+macro: bfissue /Blackfriday/ Issue #[[https://github.com/russross/blackfriday/issues/$1][$1]]
#+macro: commit commit [[https://github.com/kaushalmodi/ox-hugo/commit/$1][$1]]

# https://scripter.co/latex-in-html/
#+macro: latex @@html:<span class="latex">L<sup>a</sup>T<sub>e</sub>X</span>@@

#+author: Yichen Xu

* DONE First post generated by org-mode                                :test:
  CLOSED: [2019-11-06 Wed 00:37]
:PROPERTIES:
:EXPORT_FILE_NAME: first-post-org-mode
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:
This is my first post generated by org-mode, ox-hugo.
* DONE Switching From Purcell's Emacs.d to Spacemacs         :tutorial:emacs:
CLOSED: [2019-11-07 Thu 10:32]
:PROPERTIES:
:EXPORT_FILE_NAME: to-spacemac
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:

很久以来，我的Emacs配置都基于无比经典的Purcell的 [[https://github.com/purcell/emacs.d][emacs.d]]。但就在最近，我突然决定切换到 Spacemacs。

我曾用过一段时间的 Spacemacs，或者，确切的说，贯穿了我高二到高三的大部分时光。但
彼时对Emacs了解颇少，对Spacemacs的使用也仅限于 uncomment 几个 layer，或是复制粘
贴几句配置到 user-config 中。大一之后，一个偶然的契机，我打算更深入地学习Emacs。
那时候开始，我一直使用并轻度定制了Purcell的Emacs配置。
[[https://github.com/Linyxus/emacs.d/commits/master][Github repo]]

但老实说，不管是配置的方法还是版本管理，我在这段时间里做的真的有些随便。

** 切换到 Spacemacs 的理由

1. Evil! Spacemacs是在emacs中使用evil的最快速的方法之一
2. 系统化的配置，基于 use-package，Purcell的配置方法过于古老不便
3. Battery included，庞大的社群： [[https://github.com/syl20bnr/spacemacs][Github]] 上已有18.8k个星星
4. 丰富的文档，相较于 Purcell 的配置基本无可用文档

** Migration

事实上，除了一些无关紧要的配置，我几乎可以无痛迁移到 Spacemacs，因为 Spacemacs 的 layer 实在是太齐全丰富了。

日常使用中，我会使用Emacs编辑的文件类型其实不是很多：
- C/C++
- Org
- Haskell
- \( \LaTeX{} \)

平时虽然Python写得也比较多，但是，PyCharm真香！

上述我要用到的编辑环境，所有在 Spacemacs 中都有现成的 layer 可以用，我要做的只是
在 =dotspacemacs-configuration-layers= 中把他们加上罢了。

** 迁移过程
首先，删除原来的emacs.d。

#+begin_src bash
rm .emacs.d // my .emacs.d is just a symlink
#+end_src

然后

#+begin_src bash
git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
#+end_src

打开Emacs。Voila！

** 一些常用Layer与基本配置
- auto-completion，编辑器必备，看着舒服
- helm，也可以选ivy，个人觉得的确是ivy简洁好看一些，但helm是默认之选，官方文档中
  也提到如果选择ivy，一些功能也许不可用。[[https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org#completion][Documentation]]
- org，不得不说，Spacemacs自带的org layer实在是太好用了！

除此以外，因为看惯了Purcell用的Tomorrow系列theme，对spacemacs自带的theme系列有些
不习惯。而且spacemacs-dark在org下实在是太难看了些，故而还是配了一下tomorrow系列
的theme，看起来很习惯。
[[file:spacemacs.png]]

只需要把tomorrow theme对应的package加到dotfile的additional-packages中即可。
#+BEGIN_SRC emacs-lisp
dotspacemacs-additional-packages '(color-theme-sanityinc-tomorrow)
#+END_SRC

别忘了选一个color theme作为默认。
#+begin_src emacs-lisp
dotspacemacs-themes '(sanityinc-tomorrow-eighties
                      spacemacs-dark
                      spacemacs-light)
#+end_src

** Version Control
Spacemacs的版本控制有很多种方式。简单来说，Spacemacs的配置文件分为以下部分
1. Spacemacs主体，也就是 =.emacs.d= 中的大部分内容。这一部分至少对我而言并不需要
   进行版本控制，因为我基本不会对其进行修改，直接跟着上游就可以了。
2. .spacemacs。也就是我基于Spacemacs的配置文件。
3. Private layers。也就是自己写的layer。

文档中有所提及的是，private layer所在的文件夹是会被Spacemacs主git repo忽略的。如
果要对我们的自用layer进行版本控制，可以简单地在private文件夹建立一个repo，或是把
一个repo symlink到private文件夹，效果类似。

但这么做有一个巨大的弊端：.spacemacs和private layer不能很好地放在一起管理。有一
个显然的解决方案：建一个管理Spacemacs配置文件的repo，里面包含一个.spacemacs文件，
一个private文件夹，再分别symlink到相应位置，但这样非常不自然。

我最终选择了另一个解决方案。[[https://github.com/syl20bnr/spacemacs/blob/master/doc/QUICK_START.org#dotdirectory-spacemacsd][文档]]中提及，除了用一个.spacemacs文件作为配置以外，
Spacemacs也可以像Emacs一样，把一个文件夹作为配置来源。具体地，新建一个文件夹
=~/.spacemacs.d= ， =~/.spacemacs.d/init.el= 即可作为原来的 =.spacemacs= 。

借助于这一特性，可以把我的Spacemacs配置和private layers集合到一个文件夹中：
#+begin_src
.spacemacs.d
├── LICENSE
├── README.org
├── init.el
└── layers
    └── ox-hugo-layer

2 directories, 3 files
#+end_src
* DONE Playing with keyboard on macOS with Karabiner         :tutorial:macos:
CLOSED: [2019-12-12 Thu 17:28]
:PROPERTIES:
:EXPORT_FILE_NAME: macos-keyboard-karabiner
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:

本文会简单地介绍 macOS 上的键盘修改工具 Karabiner，并且简单介绍我配置的修改方式。
** 引子
*** 关于 macOS 的输入法
在macOS上，一直让我很头疼的一件事情是自带的输入法对中文输入不是非常友好。由于对
中文输入者而言，在中英文之间切换是相对常见的操作，大多数人习惯使用Shift切换，因
为绝大多数中文输入法都默认这一点。但macOS上默认使用Capslock。

这并不是关键之处，让我完全不能好好使用macOS自带输入法的根本原因会在下面提到：我
需要把Capslock用作他用。

事实上，第三方输入法我也尝试过，从国产经典的搜狗，到较为小众的落格。搜狗的毛病在
于有广告，界面也未免太花里胡哨，而落格的致命之处在于词库实在太难用，有时候首选词
叫人完全无法理解，不仅如此，落格最主要的卖点：双拼，也对使用全拼的我毫无吸引力。

通过 Karabiner，可以把Shift配置为我想要的样子。
*** 关于修改CapsLock
修改CapsLock应该是很多程序员的必备操作了。Capslock的位置处于整张键盘上最容易按到
的地方之一，却基本是最少使用到的按键，这很不合理。

我们可以把Capslock转而映射到Control（对于Emacs用户）或Escape（对于Vim用户）来很
大地提高键盘的使用效率。

之前发现了一个很棒的工具，名为[[https://github.com/alols/xcape][Xcape]]，能够 *同时* 把Capslock映射到Control与Escape，
这很容易实现——Escape和Control的使用事实上是不重合的，使用场景有明显的差异：
Control是修饰键，与其他按键一起按下，而Escape常常是独立按下的。也可以通过按下的
时间来区分他们。

很遗憾的是，Xcape *并不支持macOS* 。

但 Karabiner 弥补了这一遗憾。

** Karabiner的安装

[[https://pqrs.org/osx/karabiner/][Karabiner]]

Karabiner 的安装非常简单，直接在官网上下载dmg，双击安装即可。

值得一提的是，Karabiner的官网上也有一个官方整理的 Complex modifications [[https://pqrs.org/osx/karabiner/complex_modifications/][集合]]，大
多数常用的修改方式只需要 import 这上面的修改即可，修改的定义方式是json，语法也颇
为直观，必要时可以修改。

** Modification I: 使用Shift切换中英文

利用 Shift 切换中英文有一个很直观的实现：单独按下时，发送Capslock，否则仍然发送
Shift。这个实现在上面提到的集合中就有 [[https://pqrs.org/osx/karabiner/complex_modifications/#shift][现成的]]。

然而，在使用过程中，我发现了一些问题：在一些情况下，如Chrome和PyCharm，这样的实
现会产生一些非常奇怪的Bug：输入的英文皆为大写。尝试解决无果，我转向了第二种方案：
类似实现，只不过直接发送切换输入法的快捷键，而不是Capslock。

#+begin_src javascript
  {
      "description": "Change left_shift to control+option+space if pressed alone (rev 2)",
      "manipulators": [
          {
              "from": {
                  "key_code": "left_shift",
                  "modifiers": {
                      "optional": [
                          "any"
                      ]
                  }
              },
              "to": [
                  {
                      "key_code": "left_shift"
                  }
              ],
              "to_if_alone": [
                  {
                      "hold_down_milliseconds": 100,
                      "key_code": "spacebar",
                      "modifiers": [
                          "left_control",
                          "left_option"
                      ]
                  }
              ],
              "type": "basic"
          }
      ]
  }
#+end_src

我切换输入法的快捷键是 control + option + space，这样的实现到目前为止完全符合预
期，毫无问题。

** Modification II: Capslock
Capslock的修改同样有[[https://pqrs.org/osx/karabiner/complex_modifications/#caps_lock][现成的]]。

Capslock这样的修改方式对Evil用户尤其友好——既兼顾了Evil的Escaping，又保护了Emacs
用户的小指。

这样修改过后，在Emacs中编辑基本不再需要离开键盘的中间区域了。

** Modification III: System-wide Vi-style navigation
第三个修改是针对方向键的，也即在全系统层面，用一个修饰键加上hjkl来作为方向键。

这一修改同样有 [[https://pqrs.org/osx/karabiner/complex_modifications/#vi_style_arrows][现成的]] 。

为了最大化的避免与Emacs中的快捷键发生冲突，我选用了option键。虽然按起来没有
Capslock来的方便，但至少也比方向键要快得多。
