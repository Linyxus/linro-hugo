#+hugo_base_dir: ../

#+seq_todo: TODO DRAFT DONE
#+seq_todo: TEST__TODO | TEST__DONE

#+property: header-args :eval never-export

#+startup: indent

#+macro: doc [[https://ox-hugo.scripter.co/doc/$1][$2]]
#+macro: oxhugoissue =ox-hugo= Issue #[[https://github.com/kaushalmodi/ox-hugo/issues/$1][$1]]
#+macro: hugoissue =hugo= Issue #[[https://github.com/gohugoio/hugo/issues/$1][$1]]
#+macro: hugopr =hugo= PR #[[https://github.com/gohugoio/hugo/pull/$1][$1]]
#+macro: bfissue /Blackfriday/ Issue #[[https://github.com/russross/blackfriday/issues/$1][$1]]
#+macro: commit commit [[https://github.com/kaushalmodi/ox-hugo/commit/$1][$1]]

# https://scripter.co/latex-in-html/
#+macro: latex @@html:<span class="latex">L<sup>a</sup>T<sub>e</sub>X</span>@@

#+author: Yichen Xu

* DONE First post generated by org-mode                                :test:
  CLOSED: [2019-11-06 Wed 00:37]
:PROPERTIES:
:EXPORT_FILE_NAME: first-post-org-mode
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:
This is my first post generated by org-mode, ox-hugo.
* DONE Switching From Purcell's Emacs.d to Spacemacs         :tutorial:emacs:
CLOSED: [2019-11-07 Thu 10:32]
:PROPERTIES:
:EXPORT_FILE_NAME: to-spacemac
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:

很久以来，我的Emacs配置都基于无比经典的Purcell的 [[https://github.com/purcell/emacs.d][emacs.d]]。但就在最近，我突然决定切换到 Spacemacs。

我曾用过一段时间的 Spacemacs，或者，确切的说，贯穿了我高二到高三的大部分时光。但
彼时对Emacs了解颇少，对Spacemacs的使用也仅限于 uncomment 几个 layer，或是复制粘
贴几句配置到 user-config 中。大一之后，一个偶然的契机，我打算更深入地学习Emacs。
那时候开始，我一直使用并轻度定制了Purcell的Emacs配置。
[[https://github.com/Linyxus/emacs.d/commits/master][Github repo]]

但老实说，不管是配置的方法还是版本管理，我在这段时间里做的真的有些随便。

** 切换到 Spacemacs 的理由

1. Evil! Spacemacs是在emacs中使用evil的最快速的方法之一
2. 系统化的配置，基于 use-package，Purcell的配置方法过于古老不便
3. Battery included，庞大的社群： [[https://github.com/syl20bnr/spacemacs][Github]] 上已有18.8k个星星
4. 丰富的文档，相较于 Purcell 的配置基本无可用文档

** Migration

事实上，除了一些无关紧要的配置，我几乎可以无痛迁移到 Spacemacs，因为 Spacemacs 的 layer 实在是太齐全丰富了。

日常使用中，我会使用Emacs编辑的文件类型其实不是很多：
- C/C++
- Org
- Haskell
- \( \LaTeX{} \)

平时虽然Python写得也比较多，但是，PyCharm真香！

上述我要用到的编辑环境，所有在 Spacemacs 中都有现成的 layer 可以用，我要做的只是
在 =dotspacemacs-configuration-layers= 中把他们加上罢了。

** 迁移过程
首先，删除原来的emacs.d。

#+begin_src bash
rm .emacs.d // my .emacs.d is just a symlink
#+end_src

然后

#+begin_src bash
git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
#+end_src

打开Emacs。Voila！

** 一些常用Layer与基本配置
- auto-completion，编辑器必备，看着舒服
- helm，也可以选ivy，个人觉得的确是ivy简洁好看一些，但helm是默认之选，官方文档中
  也提到如果选择ivy，一些功能也许不可用。[[https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org#completion][Documentation]]
- org，不得不说，Spacemacs自带的org layer实在是太好用了！

除此以外，因为看惯了Purcell用的Tomorrow系列theme，对spacemacs自带的theme系列有些
不习惯。而且spacemacs-dark在org下实在是太难看了些，故而还是配了一下tomorrow系列
的theme，看起来很习惯。
[[file:spacemacs.png]]

只需要把tomorrow theme对应的package加到dotfile的additional-packages中即可。
#+BEGIN_SRC emacs-lisp
dotspacemacs-additional-packages '(color-theme-sanityinc-tomorrow)
#+END_SRC

别忘了选一个color theme作为默认。
#+begin_src emacs-lisp
dotspacemacs-themes '(sanityinc-tomorrow-eighties
                      spacemacs-dark
                      spacemacs-light)
#+end_src

** Version Control
Spacemacs的版本控制有很多种方式。简单来说，Spacemacs的配置文件分为以下部分
1. Spacemacs主体，也就是 =.emacs.d= 中的大部分内容。这一部分至少对我而言并不需要
   进行版本控制，因为我基本不会对其进行修改，直接跟着上游就可以了。
2. .spacemacs。也就是我基于Spacemacs的配置文件。
3. Private layers。也就是自己写的layer。

文档中有所提及的是，private layer所在的文件夹是会被Spacemacs主git repo忽略的。如
果要对我们的自用layer进行版本控制，可以简单地在private文件夹建立一个repo，或是把
一个repo symlink到private文件夹，效果类似。

但这么做有一个巨大的弊端：.spacemacs和private layer不能很好地放在一起管理。有一
个显然的解决方案：建一个管理Spacemacs配置文件的repo，里面包含一个.spacemacs文件，
一个private文件夹，再分别symlink到相应位置，但这样非常不自然。

我最终选择了另一个解决方案。[[https://github.com/syl20bnr/spacemacs/blob/master/doc/QUICK_START.org#dotdirectory-spacemacsd][文档]]中提及，除了用一个.spacemacs文件作为配置以外，
Spacemacs也可以像Emacs一样，把一个文件夹作为配置来源。具体地，新建一个文件夹
=~/.spacemacs.d= ， =~/.spacemacs.d/init.el= 即可作为原来的 =.spacemacs= 。

借助于这一特性，可以把我的Spacemacs配置和private layers集合到一个文件夹中：
#+begin_src
.spacemacs.d
├── LICENSE
├── README.org
├── init.el
└── layers
    └── ox-hugo-layer

2 directories, 3 files
#+end_src
* DONE Playing with keyboard on macOS with Karabiner         :tutorial:macos:
CLOSED: [2019-12-12 Thu 17:28]
:PROPERTIES:
:EXPORT_FILE_NAME: macos-keyboard-karabiner
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:

本文会简单地介绍 macOS 上的键盘修改工具 Karabiner，并且简单介绍我配置的修改方式。
** 引子
*** 关于 macOS 的输入法
在macOS上，一直让我很头疼的一件事情是自带的输入法对中文输入不是非常友好。由于对
中文输入者而言，在中英文之间切换是相对常见的操作，大多数人习惯使用Shift切换，因
为绝大多数中文输入法都默认这一点。但macOS上默认使用Capslock。

这并不是关键之处，让我完全不能好好使用macOS自带输入法的根本原因会在下面提到：我
需要把Capslock用作他用。

事实上，第三方输入法我也尝试过，从国产经典的搜狗，到较为小众的落格。搜狗的毛病在
于有广告，界面也未免太花里胡哨，而落格的致命之处在于词库实在太难用，有时候首选词
叫人完全无法理解，不仅如此，落格最主要的卖点：双拼，也对使用全拼的我毫无吸引力。

通过 Karabiner，可以把Shift配置为我想要的样子。
*** 关于修改CapsLock
修改CapsLock应该是很多程序员的必备操作了。Capslock的位置处于整张键盘上最容易按到
的地方之一，却基本是最少使用到的按键，这很不合理。

我们可以把Capslock转而映射到Control（对于Emacs用户）或Escape（对于Vim用户）来很
大地提高键盘的使用效率。

之前发现了一个很棒的工具，名为[[https://github.com/alols/xcape][Xcape]]，能够 *同时* 把Capslock映射到Control与Escape，
这很容易实现——Escape和Control的使用事实上是不重合的，使用场景有明显的差异：
Control是修饰键，与其他按键一起按下，而Escape常常是独立按下的。也可以通过按下的
时间来区分他们。

很遗憾的是，Xcape *并不支持macOS* 。

但 Karabiner 弥补了这一遗憾。

** Karabiner的安装

[[https://pqrs.org/osx/karabiner/][Karabiner]]

Karabiner 的安装非常简单，直接在官网上下载dmg，双击安装即可。

值得一提的是，Karabiner的官网上也有一个官方整理的 Complex modifications [[https://pqrs.org/osx/karabiner/complex_modifications/][集合]]，大
多数常用的修改方式只需要 import 这上面的修改即可，修改的定义方式是json，语法也颇
为直观，必要时可以修改。

** Modification I: 使用Shift切换中英文

利用 Shift 切换中英文有一个很直观的实现：单独按下时，发送Capslock，否则仍然发送
Shift。这个实现在上面提到的集合中就有 [[https://pqrs.org/osx/karabiner/complex_modifications/#shift][现成的]]。

然而，在使用过程中，我发现了一些问题：在一些情况下，如Chrome和PyCharm，这样的实
现会产生一些非常奇怪的Bug：输入的英文皆为大写。尝试解决无果，我转向了第二种方案：
类似实现，只不过直接发送切换输入法的快捷键，而不是Capslock。

#+begin_src javascript
  {
      "description": "Change left_shift to control+option+space if pressed alone (rev 2)",
      "manipulators": [
          {
              "from": {
                  "key_code": "left_shift",
                  "modifiers": {
                      "optional": [
                          "any"
                      ]
                  }
              },
              "to": [
                  {
                      "key_code": "left_shift"
                  }
              ],
              "to_if_alone": [
                  {
                      "hold_down_milliseconds": 100,
                      "key_code": "spacebar",
                      "modifiers": [
                          "left_control",
                          "left_option"
                      ]
                  }
              ],
              "type": "basic"
          }
      ]
  }
#+end_src

我切换输入法的快捷键是 control + option + space，这样的实现到目前为止完全符合预
期，毫无问题。

** Modification II: Capslock
Capslock的修改同样有[[https://pqrs.org/osx/karabiner/complex_modifications/#caps_lock][现成的]]。

Capslock这样的修改方式对Evil用户尤其友好——既兼顾了Evil的Escaping，又保护了Emacs
用户的小指。

这样修改过后，在Emacs中编辑基本不再需要离开键盘的中间区域了。

** Modification III: System-wide Vi-style navigation
第三个修改是针对方向键的，也即在全系统层面，用一个修饰键加上hjkl来作为方向键。

这一修改同样有 [[https://pqrs.org/osx/karabiner/complex_modifications/#vi_style_arrows][现成的]] 。

为了最大化的避免与Emacs中的快捷键发生冲突，我选用了option键。虽然按起来没有
Capslock来的方便，但至少也比方向键要快得多。
* DONE The magic of Laziness: from fibonacci to Y combinator (1) :tutorial:haskell:
CLOSED: [2020-02-12 Wed 21:17]
:PROPERTIES:
:EXPORT_FILE_NAME: the-magic-of-laziness
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :showDate true
:END:

在这篇博客中，我将简单地介绍许多函数式编程语言中一个重要的，也是独特的特性：Laziness。

** A first taste of Laziness
所以，什么是Laziness呢？Laziness有一个更加正式的名称：lazy evaluation，也即 /惰
性求值/ 。简单来说，惰性求值意味着，表达式的值不会被立即求出，只有当需要的时候才
会对其进行求值。

比如，下面的代码在运行时并不会报错，而可以安全地求出列表的长度。

#+begin_src haskell
  length [error "Hey!", error "Here is an error."]
  -- 2
#+end_src

原因是，在 =length= 的实现中，并不关心列表中每个元素的值是什么。因而他们并不会被
求值。

#+begin_src haskell
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs
#+end_src

这是惰性求值这一特性最为直接的展示。

而在实现上，具有惰性求值特性的代码可以这样被直观地想象：所有的值都被装在一个盒子
中，对某个值求值的过程，也就是打开盒子的过程，为了打开这个盒子之后或许我们会发现
里面有更多的盒子要打开。而所有的盒子，都会在万不得已的时候才被打开。

这个比喻很直观，但不那么确切。比较精确的说法应当基于两个定义（至少在Haskell中是
如此）：Normal Form与Weak Head Normal Form。

Normal Form的定义很简单：normal form表示一个被完全求值的值：代表它所有的部分都已
经被完全地求值完毕。 =1= ， =Just "Hello"= ，都是normal form，而 =1 + 1= 则不是。

Weak Head Normal Formd的定义则要复杂一些。简单来说，所有函数都是WHNF。所有顶层
constructor被求值的表达式也都是WHNF。

举一些简单的例子： =(1, 2 + 2)= ， =(1 + 1) : undefined= ， =Just 0= 都是WHNF，因为
他们的顶层constructor都已求值。

而一般来说，对某个值进行求值的时候，都只会将它求值为WHNF的形式。

更为详细的介绍，可以在这一篇 [[https://alpmestan.com/posts/2013-10-02-oh-my-laziness.html][文章]] 中找到。

Laziness经常被认为会导致更多的内存占用，大多数时候的确如此：因为Laziness很多时候
会导致运算过程被保存，而不是直接求出结果。但有些时候，Laziness可以带来更高的内存
使用效率，并做到若没有Laziness则完全不可能做到的事情，举一个简单的例子。

#+begin_src haskell
  x :: [Int]
  x = 1 : x
#+end_src

上面的函数定义了一个只包含 $1$ 的无穷序列。这在非Lazy的语言中是不可能做到的：它
会消耗无穷的内存。而在Lazy的语言中，它在内存中的形态不过是一个循环链表。

** 利用惰性定义无穷序列
那么，惰性到底可以做什么有用的事情呢？

下面这段代码定义了所有自然数的序列：
#+begin_src haskell
  nat :: [Int]
  nat = 0 : map (+1) nat

  -- >>> take 3 nat
  -- [0,1,2]
#+end_src

或者，可以类似地定义等比数列 $\{ 2^n \}_{n \in \mathbb N}$：
#+begin_src haskell
xs :: [Int]
xs = 1 : map (^2) nat
#+end_src

正是惰性求值的特性，给予了我们定义无穷数列的能力。考虑下面的代码：
#+begin_src haskell
take 3 nat
-- take 3 (0 : map (+1) nat)
-- 0 : take 2 (map (+1) nat)
-- 0 : take 2 (map (+1) (0 : map (+1) nat))
-- 0 : take 2 ((0 + 1) : map (+1) (map (+1) nat))
-- 0 : (0 + 1) : take 1 (map (+1) (map (+1) nat))
-- ...
-- 0 : (0 + 1) : (0 + 1 + 1) : []
-- [0,1,2]

take :: Int -> [a] -> [a]
take n xs | n <= 0 = []
take _ [] = []
take n (x:xs) = x : take (n-1) xs
#+end_src

这段代码非常简单地解释了惰性求值的过程。值得注意的是：
- 在上面的代码中，每次对列表求值时，都仅仅求值到WHNF，也即 =x : xs= 的形式。
- =take= 中的比较 $n \le 0$ 将会强制将两端都求值到NF。

上面的定义基于了这样一个事实：所有带有符合递推式 $ a_{k+1} = f(a_k), $
且首项 $a_0$ 为 $c$ 的无穷序列，都满足这一恒等式：
#+begin_src haskell
xs === c : map f xs
#+end_src

因此我们可以对所有一阶递推序列都在Haskell中非常容易地构造出对应的无穷序列。

而对于二阶递推式也是类似的。因为我们有
#+begin_src haskell
xs === x0 : x1 : zipWith f xs (drop 1 xs)
#+end_src
其中 =f= 即为二阶递推关系式。

因而可以很容易地定义出Fibonacci数列：
#+begin_src haskell
fibo :: [Int]
fibo = 1 : 1 : zipWith (+) fibo (drop 1 fibo)
#+end_src

而类似定义的这些函数，在不具备Lazy特性的语言中是没有任何用的。调用他们只会进入死
循环。

当然，归功于Laziness，我们也能对无穷序列进行很容易的操作。例如，如果你想求出
Fibonacci数列两项之差所构成的数列（这显然也是一个Fibonacci数列），可以这样写：
#+begin_src haskell
xs = zipWith subtract fibo (drop 1 fibo)
#+end_src

=xs= 也将是一个无穷序列。

在下一篇博客中，我将介绍一个非常有趣的情景：假设我们正在使用一个非常，非常，非常
简单的纯函数语言，不仅没有任何副作用，并且简单到无法定义变量：所有名称的引入都是
通过定义匿名函数完成的。而整个程序也仅仅是一个表达式而已。我们用简单的Haskell来
模拟这种语言。也即：我们只能使用Haskell中的Lambda函数，不能定义变量。
#+begin_src haskell
(\x y -> x + y) 1 2
-- 3
#+end_src

而在这一情景下，该如何实现递归呢？也即，如果无法定义一个名称，那函数该如何“引用”
自己呢？

为了在这种情况下实现递归，我会介绍Y组合子的概念，并指出，是Laziness使Y组合子的定义成为可能。
